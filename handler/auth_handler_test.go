package handler

import (
	"testing"
	proto "github.com/abaeve/auth-srv/proto"
	"github.com/abaeve/auth-srv/model"
	"github.com/abaeve/auth-srv/repository"
	"golang.org/x/net/context"
	"github.com/golang/mock/gomock"
)

//<editor-fold desc="Generated Mock Code">
/* Automatically generated by MockGen. DO NOT EDIT!
 * Source: github.com/abaeve/auth-srv/repository (interfaces: AllianceRepository,CorporationRepository,CharacterRepository,UserRepository,RoleRepository,AuthenticationCodeRepository)
 */

type MockAllianceRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockAllianceRepositoryRecorder
}

type _MockAllianceRepositoryRecorder struct {
	mock *MockAllianceRepository
}

func NewMockAllianceRepository(ctrl *gomock.Controller) *MockAllianceRepository {
	mock := &MockAllianceRepository{ctrl: ctrl}
	mock.recorder = &_MockAllianceRepositoryRecorder{mock}
	return mock
}

func (_m *MockAllianceRepository) EXPECT() *_MockAllianceRepositoryRecorder {
	return _m.recorder
}

func (_m *MockAllianceRepository) FindByAllianceId(_param0 int64) *model.Alliance {
	ret := _m.ctrl.Call(_m, "FindByAllianceId", _param0)
	ret0, _ := ret[0].(*model.Alliance)
	return ret0
}

func (_mr *_MockAllianceRepositoryRecorder) FindByAllianceId(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FindByAllianceId", arg0)
}

func (_m *MockAllianceRepository) Save(_param0 *model.Alliance) error {
	ret := _m.ctrl.Call(_m, "Save", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockAllianceRepositoryRecorder) Save(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0)
}

type MockCorporationRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockCorporationRepositoryRecorder
}

type _MockCorporationRepositoryRecorder struct {
	mock *MockCorporationRepository
}

func NewMockCorporationRepository(ctrl *gomock.Controller) *MockCorporationRepository {
	mock := &MockCorporationRepository{ctrl: ctrl}
	mock.recorder = &_MockCorporationRepositoryRecorder{mock}
	return mock
}

func (_m *MockCorporationRepository) EXPECT() *_MockCorporationRepositoryRecorder {
	return _m.recorder
}

func (_m *MockCorporationRepository) FindByCorporationId(_param0 int64) *model.Corporation {
	ret := _m.ctrl.Call(_m, "FindByCorporationId", _param0)
	ret0, _ := ret[0].(*model.Corporation)
	return ret0
}

func (_mr *_MockCorporationRepositoryRecorder) FindByCorporationId(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FindByCorporationId", arg0)
}

func (_m *MockCorporationRepository) Save(_param0 *model.Corporation) error {
	ret := _m.ctrl.Call(_m, "Save", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockCorporationRepositoryRecorder) Save(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0)
}

type MockCharacterRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockCharacterRepositoryRecorder
}

type _MockCharacterRepositoryRecorder struct {
	mock *MockCharacterRepository
}

func NewMockCharacterRepository(ctrl *gomock.Controller) *MockCharacterRepository {
	mock := &MockCharacterRepository{ctrl: ctrl}
	mock.recorder = &_MockCharacterRepositoryRecorder{mock}
	return mock
}

func (_m *MockCharacterRepository) EXPECT() *_MockCharacterRepositoryRecorder {
	return _m.recorder
}

func (_m *MockCharacterRepository) FindByAutenticationCode(_param0 string) *model.Character {
	ret := _m.ctrl.Call(_m, "FindByAutenticationCode", _param0)
	ret0, _ := ret[0].(*model.Character)
	return ret0
}

func (_mr *_MockCharacterRepositoryRecorder) FindByAutenticationCode(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FindByAutenticationCode", arg0)
}

func (_m *MockCharacterRepository) FindByCharacterId(_param0 int64) *model.Character {
	ret := _m.ctrl.Call(_m, "FindByCharacterId", _param0)
	ret0, _ := ret[0].(*model.Character)
	return ret0
}

func (_mr *_MockCharacterRepositoryRecorder) FindByCharacterId(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FindByCharacterId", arg0)
}

func (_m *MockCharacterRepository) Save(_param0 *model.Character) error {
	ret := _m.ctrl.Call(_m, "Save", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockCharacterRepositoryRecorder) Save(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0)
}

type MockUserRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockUserRepositoryRecorder
}

type _MockUserRepositoryRecorder struct {
	mock *MockUserRepository
}

func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository {
	mock := &MockUserRepository{ctrl: ctrl}
	mock.recorder = &_MockUserRepositoryRecorder{mock}
	return mock
}

func (_m *MockUserRepository) EXPECT() *_MockUserRepositoryRecorder {
	return _m.recorder
}

func (_m *MockUserRepository) FindByChatId(_param0 string) *model.User {
	ret := _m.ctrl.Call(_m, "FindByChatId", _param0)
	ret0, _ := ret[0].(*model.User)
	return ret0
}

func (_mr *_MockUserRepositoryRecorder) FindByChatId(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "FindByChatId", arg0)
}

func (_m *MockUserRepository) LinkCharacterToUserByAuthCode(_param0 string, _param1 *model.User) error {
	ret := _m.ctrl.Call(_m, "LinkCharacterToUserByAuthCode", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockUserRepositoryRecorder) LinkCharacterToUserByAuthCode(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "LinkCharacterToUserByAuthCode", arg0, arg1)
}

func (_m *MockUserRepository) Save(_param0 *model.User) error {
	ret := _m.ctrl.Call(_m, "Save", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockUserRepositoryRecorder) Save(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0)
}

type MockRoleRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockRoleRepositoryRecorder
}

type _MockRoleRepositoryRecorder struct {
	mock *MockRoleRepository
}

func NewMockRoleRepository(ctrl *gomock.Controller) *MockRoleRepository {
	mock := &MockRoleRepository{ctrl: ctrl}
	mock.recorder = &_MockRoleRepositoryRecorder{mock}
	return mock
}

func (_m *MockRoleRepository) EXPECT() *_MockRoleRepositoryRecorder {
	return _m.recorder
}

func (_m *MockRoleRepository) Save(_param0 *model.Role) error {
	ret := _m.ctrl.Call(_m, "Save", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockRoleRepositoryRecorder) Save(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0)
}

type MockAuthenticationCodeRepository struct {
	ctrl     *gomock.Controller
	recorder *_MockAuthenticationCodeRepositoryRecorder
}

type _MockAuthenticationCodeRepositoryRecorder struct {
	mock *MockAuthenticationCodeRepository
}

func NewMockAuthenticationCodeRepository(ctrl *gomock.Controller) *MockAuthenticationCodeRepository {
	mock := &MockAuthenticationCodeRepository{ctrl: ctrl}
	mock.recorder = &_MockAuthenticationCodeRepositoryRecorder{mock}
	return mock
}

func (_m *MockAuthenticationCodeRepository) EXPECT() *_MockAuthenticationCodeRepositoryRecorder {
	return _m.recorder
}

func (_m *MockAuthenticationCodeRepository) Save(_param0 *model.Character, _param1 string) error {
	ret := _m.ctrl.Call(_m, "Save", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockAuthenticationCodeRepositoryRecorder) Save(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Save", arg0, arg1)
}

//</editor-fold>

type testError struct {
	message string
}

func (te *testError) Error() string {
	return te.message
}

func SharedSetup(t *testing.T) (*gomock.Controller,
	*MockAuthenticationCodeRepository,
	*MockUserRepository,
	*MockCharacterRepository,
	*MockCorporationRepository,
	*MockAllianceRepository) {
	mockCtrl := gomock.NewController(t)

	repository.AuthenticationCodeRepo = NewMockAuthenticationCodeRepository(mockCtrl)
	repository.UserRepo = NewMockUserRepository(mockCtrl)
	repository.CharacterRepo = NewMockCharacterRepository(mockCtrl)
	repository.CorporationRepo = NewMockCorporationRepository(mockCtrl)
	repository.AllianceRepo = NewMockAllianceRepository(mockCtrl)

	mockAuthRepo := repository.AuthenticationCodeRepo.(*MockAuthenticationCodeRepository)
	mockUserRepo := repository.UserRepo.(*MockUserRepository)
	mockCharRepo := repository.CharacterRepo.(*MockCharacterRepository)
	mockCorpRepo := repository.CorporationRepo.(*MockCorporationRepository)
	mockAlliRepo := repository.AllianceRepo.(*MockAllianceRepository)

	return mockCtrl, mockAuthRepo, mockUserRepo, mockCharRepo, mockCorpRepo, mockAlliRepo
}

func TestCreateEmptyDb(t *testing.T) {
	mockCtrl, mockAuthRepo, _ /*mockUserRepo*/ , mockCharRepo, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(authCreateRequest.Alliance.Id).Return(nil),
		mockAlliRepo.EXPECT().Save(
			&model.Alliance{
				AllianceId:     authCreateRequest.Alliance.Id,
				AllianceName:   authCreateRequest.Alliance.Name,
				AllianceTicker: authCreateRequest.Alliance.Ticker,
			},
		).Return(nil),

		mockCorpRepo.EXPECT().FindByCorporationId(authCreateRequest.Corporation.Id).Return(nil),
		mockCorpRepo.EXPECT().Save(
			&model.Corporation{
				CorporationId:     authCreateRequest.Corporation.Id,
				CorporationName:   authCreateRequest.Corporation.Name,
				CorporationTicker: authCreateRequest.Corporation.Ticker,
				AllianceId:        authCreateRequest.Alliance.Id,
				Alliance: model.Alliance{
					AllianceId:     authCreateRequest.Alliance.Id,
					AllianceName:   authCreateRequest.Alliance.Name,
					AllianceTicker: authCreateRequest.Alliance.Ticker,
				},
			},
		).Return(nil),

		mockCharRepo.EXPECT().FindByCharacterId(authCreateRequest.Character.Id).Return(nil),
		mockCharRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
		).Return(nil),

		mockAuthRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
			gomock.Any(),
		).Return(nil),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err != nil {
		t.Fatalf("Received an error on Create call, expected nothing: %s", err)
	}

	if authCreateResponse.AuthenticationCode == "" {
		t.Fatal("Expected at least something as an authentication code, got nothing")
	}
}

func TestAllianceExistsNoCorpOrChar(t *testing.T) {
	mockCtrl, mockAuthRepo, _ /*mockUserRepo*/ , mockCharRepo, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(authCreateRequest.Alliance.Id).Return(&model.Alliance{
			AllianceId:     authCreateRequest.Alliance.Id,
			AllianceName:   authCreateRequest.Alliance.Name,
			AllianceTicker: authCreateRequest.Alliance.Ticker,
		}),
		mockAlliRepo.EXPECT().Save(&model.Alliance{}).Times(0),

		mockCorpRepo.EXPECT().FindByCorporationId(authCreateRequest.Corporation.Id).Return(nil),
		mockCorpRepo.EXPECT().Save(
			&model.Corporation{
				CorporationId:     authCreateRequest.Corporation.Id,
				CorporationName:   authCreateRequest.Corporation.Name,
				CorporationTicker: authCreateRequest.Corporation.Ticker,
				AllianceId:        authCreateRequest.Alliance.Id,
				Alliance: model.Alliance{
					AllianceId:     authCreateRequest.Alliance.Id,
					AllianceName:   authCreateRequest.Alliance.Name,
					AllianceTicker: authCreateRequest.Alliance.Ticker,
				},
			},
		).Return(nil),

		mockCharRepo.EXPECT().FindByCharacterId(authCreateRequest.Character.Id).Return(nil),
		mockCharRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
		).Return(nil),

		mockAuthRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
			gomock.Any(),
		).Return(nil),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err != nil {
		t.Fatalf("Received an error on Create call, expected nothing: %s", err)
	}

	if authCreateResponse.AuthenticationCode == "" {
		t.Fatal("Expected at least something as an authentication code, got nothing")
	}
}

func TestAllianceAndCorpExistButNoChar(t *testing.T) {
	mockCtrl, mockAuthRepo, _ /*mockUserRepo*/ , mockCharRepo, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(authCreateRequest.Alliance.Id).Return(&model.Alliance{
			AllianceId:     authCreateRequest.Alliance.Id,
			AllianceName:   authCreateRequest.Alliance.Name,
			AllianceTicker: authCreateRequest.Alliance.Ticker,
		}),
		mockAlliRepo.EXPECT().Save(&model.Alliance{}).Times(0),

		mockCorpRepo.EXPECT().FindByCorporationId(authCreateRequest.Corporation.Id).Return(&model.Corporation{
			CorporationId:     authCreateRequest.Corporation.Id,
			CorporationName:   authCreateRequest.Corporation.Name,
			CorporationTicker: authCreateRequest.Corporation.Ticker,
			AllianceId:        authCreateRequest.Alliance.Id,
			Alliance: model.Alliance{
				AllianceId:     authCreateRequest.Alliance.Id,
				AllianceName:   authCreateRequest.Alliance.Name,
				AllianceTicker: authCreateRequest.Alliance.Ticker,
			},
		}),
		mockCorpRepo.EXPECT().Save(&model.Corporation{}).Times(0),

		mockCharRepo.EXPECT().FindByCharacterId(authCreateRequest.Character.Id).Return(nil),
		mockCharRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
		).Return(nil),

		mockAuthRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
			gomock.Any(),
		).Return(nil),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err != nil {
		t.Fatalf("Received an error on Create call, expected nothing: %s", err)
	}

	if authCreateResponse.AuthenticationCode == "" {
		t.Fatal("Expected at least something as an authentication code, got nothing")
	}
}

func TestAllianceAndCorpAndCharExist(t *testing.T) {
	mockCtrl, mockAuthRepo, _ /*mockUserRepo*/ , mockCharRepo, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(authCreateRequest.Alliance.Id).Return(&model.Alliance{
			AllianceId:     authCreateRequest.Alliance.Id,
			AllianceName:   authCreateRequest.Alliance.Name,
			AllianceTicker: authCreateRequest.Alliance.Ticker,
		}),
		mockAlliRepo.EXPECT().Save(&model.Alliance{}).Times(0),

		mockCorpRepo.EXPECT().FindByCorporationId(authCreateRequest.Corporation.Id).Return(&model.Corporation{
			CorporationId:     authCreateRequest.Corporation.Id,
			CorporationName:   authCreateRequest.Corporation.Name,
			CorporationTicker: authCreateRequest.Corporation.Ticker,
		}),
		mockCorpRepo.EXPECT().Save(&model.Corporation{}).Times(0),

		mockCharRepo.EXPECT().FindByCharacterId(authCreateRequest.Character.Id).Return(&model.Character{
			CharacterId:   authCreateRequest.Character.Id,
			CharacterName: authCreateRequest.Character.Name,
			Token:         authCreateRequest.Token,
			CorporationId: authCreateRequest.Corporation.Id,
			Corporation: model.Corporation{
				CorporationId:     authCreateRequest.Corporation.Id,
				CorporationName:   authCreateRequest.Corporation.Name,
				CorporationTicker: authCreateRequest.Corporation.Ticker,
				AllianceId:        authCreateRequest.Alliance.Id,
				Alliance: model.Alliance{
					AllianceId:     authCreateRequest.Alliance.Id,
					AllianceName:   authCreateRequest.Alliance.Name,
					AllianceTicker: authCreateRequest.Alliance.Ticker,
				},
			},
		}),
		mockCharRepo.EXPECT().Save(&model.Character{}).Times(0),

		mockAuthRepo.EXPECT().Save(
			&model.Character{
				CharacterId:   authCreateRequest.Character.Id,
				CharacterName: authCreateRequest.Character.Name,
				Token:         authCreateRequest.Token,
				CorporationId: authCreateRequest.Corporation.Id,
				Corporation: model.Corporation{
					CorporationId:     authCreateRequest.Corporation.Id,
					CorporationName:   authCreateRequest.Corporation.Name,
					CorporationTicker: authCreateRequest.Corporation.Ticker,
					AllianceId:        authCreateRequest.Alliance.Id,
					Alliance: model.Alliance{
						AllianceId:     authCreateRequest.Alliance.Id,
						AllianceName:   authCreateRequest.Alliance.Name,
						AllianceTicker: authCreateRequest.Alliance.Ticker,
					},
				},
			},
			gomock.Any(),
		).Return(nil),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err != nil {
		t.Fatalf("Received an error on Create call, expected nothing: %s", err)
	}

	if authCreateResponse.AuthenticationCode == "" {
		t.Fatal("Expected at least something as an authentication code, got nothing")
	}
}

func TestAllianceErrorCondition(t *testing.T) {
	mockCtrl, _, _, _, _, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(authCreateRequest.Alliance.Id).Return(nil),
		mockAlliRepo.EXPECT().Save(gomock.Any()).Return(&testError{message: "Don't do that"}),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err == nil && err.Error() == "Don't do that" {
		t.Fatal("Expected an error but got nothing")
	}
}

func TestCorporationErrorCondition(t *testing.T) {
	mockCtrl, _, _, _, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(gomock.Any()).Return(nil),
		mockAlliRepo.EXPECT().Save(gomock.Any()).Times(1),

		mockCorpRepo.EXPECT().FindByCorporationId(gomock.Any()).Return(nil),
		mockCorpRepo.EXPECT().Save(gomock.Any()).Return(&testError{message: "Don't do that"}),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err == nil && err.Error() == "Don't do that" {
		t.Fatal("Expected an error but got nothing")
	}
}

func TestCharacterErrorCondition(t *testing.T) {
	mockCtrl, _, _, mockCharRepo, mockCorpRepo, mockAlliRepo := SharedSetup(t)
	defer mockCtrl.Finish()

	authCreateRequest := proto.AuthCreateRequest{
		Token:       "mytoken",
		Alliance:    &proto.Alliance{Name: "Test Alliance", Id: 1, Ticker: "TSTA"},
		Corporation: &proto.Corporation{Name: "Test Corp", Id: 1, Ticker: "TSTC"},
		Character:   &proto.Character{Name: "Test Character", Id: 1},
		AuthScope:   []string{"scope1", "scope2"},
	}
	var authCreateResponse proto.AuthCreateResponse
	var context context.Context

	authHandler := AuthHandler{}

	//Set our expectations
	gomock.InOrder(
		mockAlliRepo.EXPECT().FindByAllianceId(gomock.Any()).Return(nil),
		mockAlliRepo.EXPECT().Save(gomock.Any()).Times(1),

		mockCorpRepo.EXPECT().FindByCorporationId(gomock.Any()).Return(nil),
		mockCorpRepo.EXPECT().Save(gomock.Any()).Times(1),

		mockCharRepo.EXPECT().FindByCharacterId(gomock.Any()).Return(nil),
		mockCharRepo.EXPECT().Save(gomock.Any()).Return(&testError{message: "Don't do that"}),
	)

	err := authHandler.Create(context, &authCreateRequest, &authCreateResponse)

	if err == nil && err.Error() == "Don't do that" {
		t.Fatal("Expected an error but got nothing")
	}
}

func TestConfirm(t *testing.T) {

}
